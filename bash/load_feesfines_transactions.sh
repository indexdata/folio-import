#!/bin/bash

function usage {
  echo
  cat << EOF
Usage: $0 <jsonl_file>

Where:
  jsonl_file = JSONL data file.
  Format: {"verb": "xxx", "accountId": "uuid", "data": {...}}

Loads the feesfines transactions to already established accounts.
The "verb" are "pay" "waive" etc.
https://dev.folio.org/reference/api/#mod-feesfines-accounts
The "data" is generated by python/spl_feesfines.py for example.

It first checks that each transaction is okay, then loads it.

EOF
}

input_fn=$1;
if [ -z $input_fn ]; then
  usage >&2
  exit
fi
if [ ! -f $input_fn ]; then
  echo 'File not found' >&2
  usage >&2
  exit
fi

TMP='./.okapi'
OKAPI=`cat ${TMP}/url`
TOKEN=`cat ${TMP}/token`
cmd_curl="curl --http1.1 -H Content-type:application/json -H X-Okapi-Token:${TOKEN}"
output_pn="/tmp/load_feesfines_transactions.json"

if [ ! -d 'log' ]; then
  mkdir 'log'
fi
date_start_utc_compact=$(date -u "+%Y%m%d")
log_fn="log/feesfines-transactions-${date_start_utc_compact}.txt"
echo "Input file: $input_fn" > $log_fn

line_num=0;
while IFS= read -r line; do
  line_num=$(expr $line_num + 1)
  date_utc=$(date -u "+%Y-%m-%d %H:%M:%S")
  verb=$(echo $line | jq -r '.verb')
  account_id=$(echo $line | jq -r '.accountId')
  amount=$(echo $line | jq -r '.data.amount')
  endpoint="${OKAPI}/accounts/${account_id}"
  echo >> $log_fn
  echo "Record #${line_num}: $verb $amount $account_id ${date_utc}" >> $log_fn
  echo $line | jq '.data' > .okapi/payload
  status=$(${cmd_curl} -s -S -w "%{http_code}" "${endpoint}/check-${verb}" -d "{\"amount\": \"${amount}\"}" -o $output_pn)
  if [ "$status" != "200" ] && [ "$status" != "422" ]; then
    msg=$(cat $output_pn)
    echo "ERROR: #${line_num}: $status: ${msg}" >> $log_fn
    continue
  fi
  if [ "$status" == "422" ]; then
    msg=$(cat $output_pn | jq -r '.errorMessage')
    echo "ERROR: #${line_num}: $status: ${msg}" >> $log_fn
    continue
  fi
  status=$(${cmd_curl} -s -S -w "%{http_code}" "${endpoint}/${verb}" -d @.okapi/payload -o $output_pn)
  if [ "$status" != "201" ] && [ "$status" != "422" ]; then
    msg=$(cat $output_pn)
    echo "ERROR: #${line_num}: $status: ${msg}" >> $log_fn
    continue
  fi
  if [ "$status" == "422" ]; then
    msg=$(cat $output_pn | jq -r '.errorMessage')
    if [ "$msg" == "null" ]; then
      msg=$(cat $output_pn)
    fi
    echo "ERROR: #${line_num}: $status: ${msg}" >> $log_fn
    continue
  fi
  echo ${status} >> $log_fn
done < $input_fn
